#include <Arduino.h>
#include "config.h"
#include "state.h"
#include "uart_handler.h"
#include "servo_controller.h"
#include "light_controller.h"
#include "limit_switch.h"

// Global state
DeviceState g_state;

// Timing
uint32_t g_last_loop_time = 0;
uint32_t g_last_status_time = 0;
uint32_t g_last_command_time = 0;
bool g_has_received_command = false;

// Test LED state
uint32_t g_test_triggered_time = 0;
bool g_test_led_on = false;

// Forward declarations
void update_servo(DeviceState *state);
void update_lights(DeviceState *state);
void check_test_command(DeviceState *state);
void update_test_led();

void setup()
{
    // Initialize USB serial for protocol communication
    Serial.begin(115200);

    // Initialize test LED
    pinMode(TEST_LED_PIN, OUTPUT);
    digitalWrite(TEST_LED_PIN, LOW);

    // Initialize state
    state_init(&g_state);

    // Initialize components
    uart_init();
    servo_init();
    light_init();
    limit_switch_init();
}

void loop()
{
    uint32_t now = millis();

    // Update test LED (non-blocking)
    update_test_led();

    // Rate limit main loop
    if (now - g_last_loop_time < LOOP_PERIOD_MS)
    {
        delay(1);
        return;
    }
    g_last_loop_time = now;

    // Read limit switch
    bool limit_active;
    uint8_t limit_dir;
    limit_switch_read(&limit_active, &limit_dir);
    state_update_limit(&g_state, limit_active, limit_dir);

    // Receive and parse commands
    uart_receive(&g_state);

    // Check connection status
    state_check_connection(&g_state, CONNECTION_TIMEOUT_MS);

    // Check for test command
    check_test_command(&g_state);

    // Update servo position
    update_servo(&g_state);

    // Update lights
    update_lights(&g_state);

    // Send status if connected (received command within 1 second)
    bool connected = g_has_received_command && (now - g_last_command_time) < 1000;
    if (connected && (now - g_last_status_time >= STATUS_TX_PERIOD_MS))
    {
        uart_send_status(&g_state);
        g_last_status_time = now;
    }
}

void on_command_received()
{
    g_last_command_time = millis();
    g_has_received_command = true;
}

bool is_test_active()
{
    if (g_test_triggered_time == 0)
    {
        return false;
    }
    return (millis() - g_test_triggered_time) < 1000;
}

void check_test_command(DeviceState *state)
{
    if ((state->command.flags & CMD_FLAG_LED_TEST) && !g_test_led_on)
    {
        // Turn on LED and record time
        g_test_led_on = true;
        g_test_triggered_time = millis();
        digitalWrite(TEST_LED_PIN, HIGH);

        // Clear flag
        state->command.flags &= ~CMD_FLAG_LED_TEST;
    }
}

void update_test_led()
{
    if (g_test_led_on)
    {
        if ((millis() - g_test_triggered_time) >= TEST_LED_DURATION_MS)
        {
            // Turn off LED after duration
            digitalWrite(TEST_LED_PIN, LOW);
            g_test_led_on = false;
        }
    }
}

void update_servo(DeviceState *state)
{
    float target = state->command.target_servo_angle;
    float current = state->output.servo_angle;

    // Check limit switch constraints
    if (state->input.limit_triggered)
    {
        if (state->input.limit_direction == LIMIT_CW && target > current)
        {
            target = current;
        }
        else if (state->input.limit_direction == LIMIT_CCW && target < current)
        {
            target = current;
        }
    }

    // Move servo toward target
    float new_angle = servo_move_toward(current, target, SERVO_SPEED);
    bool moving = (abs(new_angle - target) > 0.1f);

    state_update_servo(state, new_angle, moving);
}

void update_lights(DeviceState *state)
{
    bool should_be_on = false;

    switch (state->command.light_command)
    {
    case LIGHT_CMD_OFF:
        should_be_on = false;
        break;
    case LIGHT_CMD_ON:
        should_be_on = true;
        break;
    case LIGHT_CMD_AUTO:
        should_be_on = state->output.light_on;
        break;
    default:
        should_be_on = false;
        break;
    }

    light_set(should_be_on);
    state_update_light(state, should_be_on);
}
